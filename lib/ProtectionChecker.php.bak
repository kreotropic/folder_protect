<?php
namespace OCA\FolderProtection;

use OCP\IDBConnection;
use OCP\ICacheFactory;
use OCP\ICache;

class ProtectionChecker {

    private IDBConnection $db;
    private ICache $cache;

    public function __construct(IDBConnection $db, ICacheFactory $cacheFactory) {
        $this->db = $db;
        // usar um namespace para a cache da app
        $this->cache = $cacheFactory->createDistributed('folder_protection');
    }

    /**
     * Verifica se um path está protegido (exact match)
     */
    public function isProtected(string $path): bool {
        $path = $this->normalizePath($path);
        error_log("FolderProtection: ProtectionChecker checking path: '$path'");

        // Check cache first
        $cacheKey = 'protected_' . md5($path);
        $cached = $this->cache->get($cacheKey);
        if ($cached !== null) {
            error_log("FolderProtection: Cache hit for '$path': " . ($cached ? 'PROTECTED' : 'NOT PROTECTED'));
            return (bool)$cached;
        }

        // Check database
        $result = $this->checkDatabaseExact($path);
        error_log("FolderProtection: Database check for '$path': " . ($result ? 'PROTECTED' : 'NOT PROTECTED'));

        // Cache result for 5 minutes
        $this->cache->set($cacheKey, $result ? 1 : 0, 300);

        return $result;
    }

    /**
     * Verifica se existe uma entrada EXACTA na tabela folder_protection
     */
    private function checkDatabaseExact(string $path): bool {
        $qb = $this->db->getQueryBuilder();
        $qb->select('id')
           ->from('folder_protection')
           ->where($qb->expr()->eq('path', $qb->createNamedParameter($path)));

        $result = $qb->executeQuery();
        // usar fetchAssociative quando disponível
        $row = method_exists($result, 'fetchAssociative') ? $result->fetchAssociative() : $result->fetch();
        $result->closeCursor();

        return $row !== false && $row !== null;
    }

    /**
     * PoC helper: verifica se existe alguma pasta protegida com o mesmo basename
     * (útil como heurística para evitar copy-then-delete do client desktop)
     */
    public function isAnyProtectedWithBasename(string $basename): bool {
        $basename = trim($basename, "/");
        if ($basename === '') {
            return false;
        }
        $candidate = '/' . $basename;

        $qb = $this->db->getQueryBuilder();
        $qb->select('id')
           ->from('folder_protection')
           ->where($qb->expr()->eq('path', $qb->createNamedParameter($candidate)));

        $result = $qb->executeQuery();
        $row = method_exists($result, 'fetchAssociative') ? $result->fetchAssociative() : $result->fetch();
        $result->closeCursor();

        return $row !== false && $row !== null;
    }

    /**
     * Normaliza paths usados na DB: remove slashes redundantes e garante leading slash.
     * Ex: "" -> "/", "foo/bar" -> "/foo/bar"
     */
    public function normalizePath(string $path): string {
        $trimmed = trim($path, '/');
        if ($trimmed === '') {
            return '/';
        }
        return '/' . $trimmed;
    }

}
